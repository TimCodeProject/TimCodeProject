import tkinter as tk
from tkinter import messagebox
import csv
import statistics
import math
import itertools

def мода(список):
    """Возвращает моду списка."""
    return statistics.mode(список)

def медиана(список):
    """Возвращает медиану списка."""
    return statistics.median(список)

def дисперсия(список):
    """Возвращает дисперсию списка."""
    return statistics.variance(список)

def стандартное_отклонение(список):
    """Возвращает стандартное отклонение списка."""
    return statistics.stdev(список)

def среднее_арифметическое(список):
    """Возвращает среднее арифметическое списка."""
    return statistics.mean(список)

def квартиль(список, q):
    """Возвращает q-й квартиль списка (q=0.25, 0.5, 0.75)."""
    return statistics.quantiles(список, n=4)[int(q * 4 - 1)]

def перцентиль(список, p):
    """Возвращает p-й перцентиль списка."""
    return statistics.percentile(список, p)

def корреляция(список1, список2):
    """Возвращает коэффициент корреляции Пирсона между двумя списками."""
    return statistics.correlation(список1, список2)

def ковариация(список1, список2):
    """Возвращает ковариацию между двумя списками."""
    return statistics.covariance(список1, список2)

def вероятность(успехи, испытания):
    """Возвращает вероятность успешного исхода."""
    return успехи / испытания if испытания > 0 else 0

def биномиальное_распределение2(n, k, p):
    """Возвращает вероятность k успешных исходов в n испытаниях."""
    coeff = math.comb(n, k)
    return coeff * (p ** k) * ((1 - p) ** (n - k))

def среднее_квадратичное_отклонение(список):
    """Возвращает среднее квадратичное отклонение списка."""
    return math.sqrt(дисперсия(список))

def доверительный_интервал(список, z=1.96):
    """Возвращает доверительный интервал для среднего."""
    n = количество(списка)
    avg = среднее(список)
    stddev = стандартное_отклонение(список)
    ошибка = z * (stddev / math.sqrt(n))
    return (avg - ошибка, avg + ошибка)

#Класс таблицы
class Таблица:
    def __init__(self):
        self.таблицы = {}

    def создать_таблицу(self, имя):
        if имя not in self.таблицы:
            self.таблицы[имя] = {'столбцы': {}, 'строки': []}
        else:
            print(f"Таблица '{имя}' уже существует.")

    def создать_столбец(self, таблица, имя):
        if таблица in self.таблицы:
            if имя not in self.таблицы[таблица]['столбцы']:
                self.таблицы[таблица]['столбцы'][имя] = []
            else:
                print(f"Столбец '{имя}' уже существует в таблице '{таблица}'.")
        else:
            print(f"Таблицы '{таблица}' не существует.")

    def создать_строку(self, таблица, данные):
        if таблица in self.таблицы:
            строка = {}
            for столбец, значение in данные.items():
                значение = self.обработать_значение(значение)
                строка[столбец] = значение
                if столбец in self.таблицы[таблица]['столбцы']:
                    self.таблицы[таблица]['столбцы'][столбец].append(значение)
            self.таблицы[таблица]['строки'].append(строка)
        else:
            print(f"Таблицы '{таблица}' не существует.")

    def обработать_значение(self, значение):
        """Обрабатывает значение, позволяя вводить числа, дроби и функции."""
        try:
            if isinstance(значение, (int, float)):
                return значение
            elif isinstance(значение, str):
                if значение.startswith('/'):
                    return eval(значение[1:])
                else:
                    return eval(repr(значение))
            else:
                return значение
        except Exception as e:
            print(f"Ошибка при обработке значения '{значение}': {e}")
            return None

    def отобразить_таблицу(self, имя):
        if имя in self.таблицы:
            таблица = self.таблицы[имя]
            окно = tk.Tk()
            окно.title(f"Таблица: {имя}")

            # Создаем заголовки столбцов
            for idx, столбец in enumerate(таблица['столбцы']):
                label = tk.Label(окно, text=столбец, borderwidth=1, relief="solid")
                label.grid(row=0, column=idx, sticky="nsew")

            # Заполняем строки значениями
            for row_idx, строка in enumerate(таблица['строки']):
                for col_idx, столбец in enumerate(таблица['столбцы']):
                    значение = строка.get(столбец)
                    label = tk.Label(окно, text=значение, borderwidth=1, relief="solid")
                    label.grid(row=row_idx + 1, column=col_idx, sticky="nsew")

            # Настройка растяжения ячеек
            for idx in range(len(таблица['столбцы'])):
                окно.grid_columnconfigure(idx, weight=1)

            окно.mainloop()
        else:
            print(f"Таблицы '{имя}' не существует.")

    def получить_столбец(self, таблица, имя):
        if таблица in self.таблицы and имя in self.таблицы[таблица]['столбцы']:
            столбец = self.таблицы[таблица]['столбцы'][имя]
            return [значение for значение in столбец]
        else:
            print(f"Таблица '{таблица}' или столбец '{имя}' не существует.")
            return []

    def получить_значение(self, таблица, столбец, номер):
        if таблица in self.таблицы and столбец in self.таблицы[таблица]['столбцы']:
            данные = self.таблицы[таблица]['столбцы'][столбец]
            if 0 <= номер < len(данные):
                значение = данные[номер]
                return значение
            else:
                print(f"Номер строки '{номер}' вне диапазона.")
                return None
        else:
            print(f"Таблица '{таблица}' или столбец '{столбец}' не существует.")
            return None

    def счет_столбца(self, таблица, столбец=None, значение=None):
        if таблица in self.таблицы:
            if столбец:
                if столбец in self.таблицы[таблица]['столбцы']:
                    if значение is not None:
                        return sum(1 for val in self.таблицы[таблица]['столбцы'][столбец] if val == значение)
                    else:
                        return len(self.таблицы[таблица]['столбцы'][столбец])
                else:
                    print(f"Столбец '{столбец}' не существует в таблице '{таблица}'.")
                    return 0
            else:
                # Подсчет всех строк в таблице
                return sum(len(col) for col in self.таблицы[таблица]['столбцы'].values())
        return 0

    def счетесли_столбца(self, таблица, столбец, условие):
        if таблица in self.таблицы:
            if столбец in self.таблицы[таблица]['столбцы']:
                результат = 0
                for значение in self.таблицы[таблица]['столбцы'][столбец]:
                    try:
                        if eval(f'значение {условие}'):
                            результат += 1
                    except Exception as e:
                        print(f"Ошибка при оценке условия '{условие}' для значения '{значение}': {e}")
                return результат
        return 0

    def среднее_столбца(self, таблица, столбец):
        if таблица in self.таблицы and столбец in self.таблицы[таблица]['столбцы']:
            данные = self.таблицы[таблица]['столбцы'][столбец]
            числовые_данные = [x for x in данные if isinstance(x, (int, float))]
            if числовые_данные:
                return sum(числовые_данные) / len(числовые_данные)
        return None

    def максимум_столбца(self, таблица, столбец):
        if таблица in self.таблицы and столбец in self.таблицы[таблица]['столбцы']:
            данные = self.таблицы[таблица]['столбцы'][столбец]
            числовые_данные = [x for x in данные if isinstance(x, (int, float))]
            if числовые_данные:
                return max(числовые_данные)
        return None
    
    def сумма_столбца(self, таблица, столбец):
        if таблица in self.таблицы and столбец in self.таблицы[таблица]['столбцы']:
            данные = self.таблицы[таблица]['столбцы'][столбец]
            числовые_данные = [x for x in данные if isinstance(x, (int, float))]
            if числовые_данные:
                return sum(числовые_данные)
        return None
    
    def мода_столбца(self, таблица, столбец):
        if таблица in self.таблицы and столбец in self.таблицы[таблица]['столбцы']:
            данные = self.таблицы[таблица]['столбцы'][столбец]
            числовые_данные = [x for x in данные if isinstance(x, (int, float))]
            if числовые_данные:
                return statistics.mode(числовые_данные)
        return None
    
    def медиана_столбца(self, таблица, столбец):
        if таблица in self.таблицы and столбец in self.таблицы[таблица]['столбцы']:
            данные = self.таблицы[таблица]['столбцы'][столбец]
            числовые_данные = [x for x in данные if isinstance(x, (int, float))]
            if числовые_данные:
                return statistics.median(числовые_данные)
        return None
    
    def медиана_столбца(self, таблица, столбец):
        if таблица in self.таблицы and столбец in self.таблицы[таблица]['столбцы']:
            данные = self.таблицы[таблица]['столбцы'][столбец]
            числовые_данные = [x for x in данные if isinstance(x, (int, float))]
            if числовые_данные:
                return statistics.median(числовые_данные)
        return None


    def минимум_столбца(self, таблица, столбец):
        if таблица in self.таблицы and столбец in self.таблицы[таблица]['столбцы']:
            данные = self.таблицы[таблица]['столбцы'][столбец]
            числовые_данные = [x for x in данные if isinstance(x, (int, float))]
            if числовые_данные:
                return min(числовые_данные)
        return None

    def удалить_строку(self, таблица, номер):
        if таблица in self.таблицы:
            if 0 <= номер < len(self.таблицы[таблица]['строки']):
                del self.таблицы[таблица]['строки'][номер]
                for столбец in self.таблицы[таблица]['столбцы']:
                    if номер < len(self.таблицы[таблица]['столбцы'][столбец]):
                        del self.таблицы[таблица]['столбцы'][столбец][номер]
            else:
                print(f"Номер строки '{номер}' вне диапазона.")
        else:
            print(f"Таблицы '{таблица}' не существует.")

    def очистить_таблицу(self, таблица):
        if таблица in self.таблицы:
            self.таблицы[таблица]['строки'].clear()
            for столбец in self.таблицы[таблица]['столбцы']:
                self.таблицы[таблица]['столбцы'][столбец].clear()
        else:
            print(f"Таблицы '{таблица}' не существует.")
            
    def обновить_значение(self, таблица, столбец, номер, новое_значение):
        if таблица in self.таблицы and столбец in self.таблицы[таблица]['столбцы']:
            данные = self.таблицы[таблица]['столбцы'][столбец]
            if 0 <= номер < len(данные):
                данные[номер] = self.обработать_значение(новое_значение)
            else:
                print(f"Номер строки '{номер}' вне диапазона.")
        else:
            print(f"Таблица '{таблица}' или столбец '{столбец}' не существует.")
    def поиск_столбца(self, таблица, столбец, значение):
        if таблица in self.таблицы and столбец in self.таблицы[таблица]['столбцы']:
            индексы = []
            for индекс, val in enumerate(self.таблицы[таблица]['столбцы'][столбец]):
                if val == значение:
                    индексы.append(индекс)
            return индексы
        else:
            print(f"Таблица '{таблица}' или столбец '{столбец}' не существует.")
            return []
    def сортировать_столбец(self, таблица, столбец, обратный=False):
        if таблица in self.таблицы and столбец in self.таблицы[таблица]['столбцы']:
            self.таблицы[таблица]['строки'].sort(key=lambda x: x[столбец], reverse=обратный)
            for строка in self.таблицы[таблица]['строки']:
                for st in self.таблицы[таблица]['столбцы']:
                    self.таблицы[таблица]['столбцы'][st] = [строка[st] for строка in self.таблицы[таблица]['строки']]
        else:
            print(f"Таблица '{таблица}' или столбец '{столбец}' не существует.")
    def группировать_столбец(self, таблица, столбец):
        if таблица in self.таблицы and столбец in self.таблицы[таблица]['столбцы']:
            группы = {}
            for строка in self.таблицы[таблица]['строки']:
                ключ = строка[столбец]
                if ключ not in группы:
                    группы[ключ] = []
                группы[ключ].append(строка)
            return группы
        else:
            print(f"Таблица '{таблица}' или столбец '{столбец}' не существует.")
            return {}
    def фильтровать_столбец(self, таблица, столбец, условие):
        if таблица in self.таблицы and столбец in self.таблицы[таблица]['столбцы']:
            результат = []
            for строка in self.таблицы[таблица]['строки']:
                значение = строка[столбец]
                if eval(f'значение {условие}'):
                    результат.append(строка)
            return результат
        else:
            print(f"Таблица '{таблица}' или столбец '{столбец}' не существует.")
            return []

    def сохранить_в_файл(self, таблица, имя_файла):
        if таблица in self.таблицы:
            with open(имя_файла, mode='w', newline='', encoding='utf-8') as файл:
                writer = csv.writer(файл)
                writer.writerow(self.таблицы[таблица]['столбцы'].keys())
                for строка in self.таблицы[таблица]['строки']:
                    writer.writerow([строка[столбец] for столбец in self.таблицы[таблица]['столбцы']])
        else:
            print(f"Таблицы '{таблица}' не существует.")

    def загрузить_из_файла(self, имя_файла):
        with open(имя_файла, mode='r', encoding='utf-8') as файл:
            reader = csv.reader(файл)
            заголовки = next(reader)
            self.создать_таблицу('Загруженная_таблица')
            for заголовок in заголовки:
                self.создать_столбец('Загруженная_таблица', заголовок)
            for строка in reader:
                данные = {заголовки[i]: строка[i] for i in range(len(заголовки))}
                self.создать_строку('Загруженная_таблица', данные)

# Пример использования
#таблица = Таблица()
#таблица.создать_таблицу('Города')
#таблица.создать_столбец('Города', 'Город')
#таблица.создать_столбец('Города', 'Популяция')
#таблица.создать_строку('Города', {'Город': 'Москва', 'Популяция': 12000000})
#таблица.создать_строку('Города', {'Город': 'Санкт-Петербург', 'Популяция': 5000000})
#таблица.создать_строку('Города', {'Город': 'Новосибирск', 'Популяция': 5000000})
#таблица.создать_строку('Города', {'Город': 'Тюмень', 'Популяция': (5000000//2)*3})
#таблица.создать_строку('Города', {'Город': 'Чернобыль', 'Популяция': 0})
#таблица.создать_строку('Города', {'Город': 'Новосибирск', 'Популяция': таблица.получить_значение("Города", "Популяция", 0) })
#таблица.удалить_строку('Города', 4)
#print(таблица.поиск('Города', 'Популяция', 5000000))
#print(таблица.счет('Города', 'Популяция', 5000000))
#print(таблица.счетесли('Города', 'Популяция',">100 and значение < 50000"))
#print(таблица.максимум('Города', 'Популяция'))
#print(таблица.минимум('Города', 'Популяция'))
#print(таблица.среднее('Города', 'Популяция'))
#print(таблица.сумма('Города', 'Популяция'))

#таблица2 = Таблица()
#таблица2.создать_таблицу('Фрукты')
#таблица2.создать_таблицу('Овощи')
#таблица2.создать_столбец('Фрукты', 'Фрукт')
#таблица2.создать_столбец('Фрукты', 'Колво')
#таблица2.создать_столбец('Фрукты', 'Тип')
#таблица2.создать_строку('Фрукты', {'Фрукт': 'Банан', 'Колво': 120, 'Тип': 'Фрукт'})
#таблица2.создать_строку('Фрукты', {'Фрукт': 'Яблоко', 'Колво': 500, 'Тип': 'Фрукт'})
#таблица2.создать_столбец('Овощи', 'Фрукт')
#таблица2.создать_столбец('Овощи', 'Колво')
#таблица2.создать_столбец('Овощи', 'Тип')
#таблица2.создать_строку('Овощи', {'Фрукт': 'Банан', 'Колво': 120, 'Тип': 'Фрукт'})
#таблица2.создать_строку('Овощи', {'Фрукт': 'Яблоко', 'Колво': 500, 'Тип': 'Фрукт'})
#таблица.отобразить_таблицу('Города')
#таблица2.отобразить_таблицу('Фрукты')
#таблица2.отобразить_таблицу('Овощи')
#таблица.сохранить_в_файл('Города', 'Города.csv')
