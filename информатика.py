#Графы
def создать_неориентированный_граф(вершины, рёбра):
    граф = {вершина: [] for вершина in вершины}
    for (u, v) in рёбра:
        граф[u].append(v)
        граф[v].append(u)
    return граф

def создать_ориентированный_граф(вершины, рёбра):
    граф = {вершина: [] for вершина in вершины}
    for (u, v) in рёбра:
        граф[u].append(v)
    return граф

def добавить_вершину(граф, вершина):
    if вершина not in граф:
        граф[вершина] = []

def добавить_ребро_неориентированный(граф, u, v):
    граф[u].append(v)
    граф[v].append(u)

def добавить_ребро_ориентированный(граф, u, v):
    граф[u].append(v)

def удалить_вершину(граф, вершина):
    if вершина in граф:
        del граф[вершина]
        for v in граф:
            граф[v] = [u for u in граф[v] if u != вершина]

def удалить_ребро_неориентированный(граф, u, v):
    if u in граф and v in граф:
        граф[u].remove(v)
        граф[v].remove(u)

def удалить_ребро_ориентированный(граф, u, v):
    if u in граф and v in граф:
        граф[u].remove(v)

def поиск_в_глубину(граф, старт):
    посещённые = set()
    стек = [старт]
    
    while стек:
        вершина = стек.pop()
        if вершина not in посещённые:
            посещённые.add(вершина)
            print(вершина)
            стек.extend(reversed(граф[вершина]))

def поиск_в_ширину(граф, старт):
    посещённые = set()
    очередь = [старт]
    
    while очередь:
        вершина = очередь.pop(0)
        if вершина not in посещённые:
            посещённые.add(вершина)
            print(вершина)
            очередь.extend(граф[вершина])

def есть_цикл(граф):
    посещённые = set()
    
    def dfs(вершина, родитель):
        посещённые.add(вершина)
        for сосед in граф[вершина]:
            if сосед not in посещённые:
                if dfs(сосед, вершина):
                    return True
            elif сосед != родитель:
                return True
        return False
    
    for вершина in граф:
        if вершина not in посещённые:
            if dfs(вершина, None):
                return True
    return False


def найти_компоненты_связности(граф):
    посещённые = set()
    компоненты = []
    
    def dfs(вершина):
        посещённые.add(вершина)
        компонента.append(вершина)
        for сосед in граф[вершина]:
            if сосед not in посещённые:
                dfs(сосед)
    
    for вершина in граф:
        if вершина not in посещённые:
            компонента = []
            dfs(вершина)
            компоненты.append(компонента)
    return компоненты

def двудольный_граф(граф):
    цвет = {}
    
    def dfs(вершина):
        for сосед in граф[вершина]:
            if сосед in цвет:
                if цвет[сосед] == цвет[вершина]:
                    return False
            else:
                цвет[сосед] = 1 - цвет[вершина]
                if not dfs(сосед):
                    return False
        return True
    
    for вершина in граф:
        if вершина not in цвет:
            цвет[вершина] = 0
            if not dfs(вершина):
                return False
    return True

def кратчайший_путь(граф, старт, цель):
    очередь = [(старт, [старт])]
    посещённые = set()
    
    while очередь:
        (вершина, путь) = очередь.pop(0)
        if вершина not in посещённые:
            if вершина == цель:
                return путь
            посещённые.add(вершина)
            for сосед in граф[вершина]:
                очередь.append((сосед, путь + [сосед]))
    return None

def топологическая_сортировка(граф):
    посещённые = set()
    результат = []
    
    def dfs(вершина):
        посещённые.add(вершина)
        for сосед in граф[вершина]:
            if сосед not in посещённые:
                dfs(сосед)
        результат.append(вершина)
    
    for вершина in граф:
        if вершина not in посещённые:
            dfs(вершина)
    return результат[::-1]

def эйлеров_цикл(граф):
    def dfs(вершина, путь):
        while граф[вершина]:
            сосед = граф[вершина].pop()
            dfs(сосед, путь)
        путь.append(вершина)
    
    путь = []
    вершина = next(iter(граф))  # Начинаем с любой вершины
    dfs(вершина, путь)
    return путь[::-1]

def минимальное_остовное_дерево(рёбра):
    рёбра.sort(key=lambda x: x[2])  # Сортируем рёбра по весу
    родитель = {вершина: вершина for вершина in set(u for u, v, w in рёбра).union(set(v for u, v, w in рёбра))}
    
    def найти(вершина):
        if родитель[вершина] != вершина:
            родитель[вершина] = найти(родитель[вершина])
        return родитель[вершина]
    
    результат = []
    for u, v, w in рёбра:
        корень_u = найти(u)
        корень_v = найти(v)
        if корень_u != корень_v:
            результат.append((u, v, w))
            родитель[корень_u] = корень_v
    return результат

def алгоритм_дейкстры(граф, старт):
    import heapq
    расстояния = {вершина: float('inf') for вершина in граф}
    расстояния[старт] = 0
    очередь = [(0, старт)]
    
    while очередь:
        текущее_расстояние, текущая_вершина = heapq.heappop(очередь)
        if текущее_расстояние > расстояния[текущая_вершина]:
            continue
        for сосед, вес in граф[текущая_вершина]:
            расстояние = текущее_расстояние + вес
            if расстояние < расстояния[сосед]:
                расстояния[сосед] = расстояние
                heapq.heappush(очередь, (расстояние, сосед))
    return расстояния
def ациклический_граф(граф):
    посещённые = set()
    стек = set()
    
    def dfs(вершина):
        посещённые.add(вершина)
        стек.add(вершина)
        for сосед in граф[вершина]:
            if сосед not in посещённые:
                if dfs(сосед):
                    return True
            elif сосед in stack:
                return True
        стек.remove(вершина)
        return False
    
    for вершина in граф:
        if вершина not in посещённые:
            if dfs(вершина):
                return False
    return True
def вершины_с_максимальной_степенью(граф):
    степени = {вершина: len(соседи) for вершина, соседи in граф.items()}
    max_степень = max(степени.values())
    return [вершина for вершина, степень in степени.items() if степень == max_степень]
def Флойд_Уоршелл(граф):
    n = len(граф)
    расстояния = [[float('inf')] * n for _ in range(n)]
    
    for i in range(n):
        for j in range(n):
            if i == j:
                расстояния[i][j] = 0
            elif граф[i][j] != 0:
                расстояния[i][j] = граф[i][j]
    
    for k in range(n):
        for i in range(n):
            for j in range(n):
                расстояния[i][j] = min(расстояния[i][j], расстояния[i][k] + расстояния[k][j])
    return расстояния

def Тарьян(граф):
    индекс = {}
    низкий = {}
    компоненты = []
    стек = []
    счётчик = 0

    def dfs(вершина):
        nonlocal счётчик
        индекс[вершина] = низкий[вершина] = счётчик
        счётчик += 1
        стек.append(вершина)
        
        for сосед in граф[вершина]:
            if сосед not in индекс:
                dfs(сосед)
                низкий[вершина] = min(низкий[вершина], низкий[сосед])
            elif сосед in стек:
                низкий[вершина] = min(низкий[вершина], индекс[сосед])
        
        if низкий[вершина] == индекс[вершина]:
            компонента = []
            while True:
                v = стек.pop()
                компонента.append(v)
                if v == вершина:
                    break
            компоненты.append(компонента)
    
    for вершина in граф:
        if вершина not in индекс:
            dfs(вершина)
    return компоненты


#Динамическое программирование
def фибоначчи(n):
    if n <= 1:
        return n
    return фибоначчи(n - 1) + фибоначчи(n - 2)
def фибоначчи_оптимизированная(n, кэш={0: 0, 1: 1}):
    if n not in кэш:
        кэш[n] = фибоначчи_оптимизированная(n - 1, кэш) + фибоначчи_оптимизированная(n - 2, кэш)
    return кэш[n]
def фибоначчи_итеративно(n):
    if n <= 1:
        return n
    a, b = 0, 1
    for _ in range(2, n + 1):
        a, b = b, a + b
    return b
def рюкзак(веса, стоимости, вместимость):
    n = len(веса)
    dp = [[0] * (вместимость + 1) for _ in range(n + 1)]
    
    for i in range(1, n + 1):
        for w in range(1, вместимость + 1):
            if веса[i - 1] <= w:
                dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - веса[i - 1]] + стоимости[i - 1])
            else:
                dp[i][w] = dp[i - 1][w]
    return dp[n][вместимость]
def lcs(X, Y): #Поиск наибольшей общей подпоследовательности (LCS)
    m, n = len(X), len(Y)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if X[i - 1] == Y[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    return dp[m][n]
def lis(последовательность): #Поиск наибольшей возрастающей подпоследовательности (LIS)
    n = len(последовательность)
    dp = [1] * n
    
    for i in range(1, n):
        for j in range(i):
            if последовательность[i] > последовательность[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)
def размен_монет(монеты, сумма):
    dp = [float('inf')] * (сумма + 1)
    dp[0] = 0
    
    for i in range(1, сумма + 1):
        for монета in монеты:
            if монета <= i:
                dp[i] = min(dp[i], dp[i - монета] + 1)
    return dp[сумма] if dp[сумма] != float('inf') else -1
def максимальный_подмассив(массив):
    текущий_макс = общий_макс = массив[0]
    
    for число in массив[1:]:
        текущий_макс = max(число, текущий_макс + число)
        общий_макс = max(общий_макс, текущий_макс)
    return общий_макс
def минимальные_шаги(n):
    dp = [0] * (n + 1)
    
    for i in range(1, n + 1):
        dp[i] = dp[i - 1] + 1
        if i % 2 == 0:
            dp[i] = min(dp[i], dp[i // 2] + 1)
        if i % 3 == 0:
            dp[i] = min(dp[i], dp[i // 3] + 1)
    return dp[n]
def путь_в_матрице(m, n):
    dp = [[1] * n for _ in range(m)]
    
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
    return dp[m - 1][n - 1]
def палиндромная_подпоследовательность(s):
    n = len(s)
    dp = [[0] * n for _ in range(n)]
    
    for i in range(n - 1, -1, -1):
        for j in range(i, n):
            if s[i] == s[j]:
                dp[i][j] = dp[i + 1][j - 1] + 2 if i != j else 1
            else:
                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])
    return dp[0][n - 1]
def расстояние_Левенштейна(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    for i in range(m + 1):
        for j in range(n + 1):
            if i == 0:
                dp[i][j] = j
            elif j == 0:
                dp[i][j] = i
            else:
                dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + (0 if s1[i - 1] == s2[j - 1] else 1))
    return dp[m][n]
def максимальная_подстрока_без_повторений(s):
    последний_индекс = {}
    старт = максимум = 0
    
    for i, символ in enumerate(s):
        if символ in последний_индекс:
            старт = max(старт, последний_индекс[символ] + 1)
        последний_индекс[символ] = i
        максимум = max(максимум, i - старт + 1)
    return максимум
def минимальные_монеты(монеты, сумма):
    dp = [float('inf')] * (сумма + 1)
    dp[0] = 0
    
    for i in range(1, сумма + 1):
        for монета in монеты:
            if монета <= i:
                dp[i] = min(dp[i], dp[i - монета] + 1)
    return dp[сумма] if dp[сумма] != float('inf') else -1
def разрезание_стержня(цены, n):
    dp = [0] * (n + 1)
    
    for i in range(1, n + 1):
        максимум = -float('inf')
        for j in range(i):
            максимум = max(максимум, цены[j] + dp[i - j - 1])
        dp[i] = максимум
    return dp[n]
def максимальная_сумма_без_соседей(массив):
    n = len(массив)
    if n == 0:
        return 0
    dp = [0] * n
    dp[0] = массив[0]
    if n > 1:
        dp[1] = max(массив[0], массив[1])
    
    for i in range(2, n):
        dp[i] = max(dp[i - 1], dp[i - 2] + массив[i])
    return dp[-1]
def максимальное_произведение_подмассива(массив):
    n = len(массив)
    if n == 0:
        return 0
    макс_продукт, мин_продукт, результат = массив[0], массив[0], массив[0]
    
    for i in range(1, n):
        if массив[i] < 0:
            макс_продукт, мин_продукт = мин_продукт, макс_продукт
        макс_продукт = max(массив[i], макс_продукт * массив[i])
        мин_продукт = min(массив[i], мин_продукт * массив[i])
        результат = max(результат, макс_продукт)
    return результат

def максимальная_сумма_подматрицы(матрица):
    m, n = len(матрица), len(матрица[0])
    максимум = -float('inf')
    
    for i in range(m):
        временный = [0] * n
        for j in range(i, m):
            for k in range(n):
                временный[k] += матрица[j][k]
            текущий_макс = временный[0]
            общий_макс = временный[0]
            for k in range(1, n):
                текущий_макс = max(временный[k], текущий_макс + временный[k])
                общий_макс = max(общий_макс, текущий_макс)
            максимум = max(максимум, общий_макс)
    return максимум
def максимальная_сумма_подматрицы(матрица):
    m, n = len(матрица), len(матрица[0])
    максимум = -float('inf')
    
    for i in range(m):
        временный = [0] * n
        for j in range(i, m):
            for k in range(n):
                временный[k] += матрица[j][k]
            текущий_макс = временный[0]
            общий_макс = временный[0]
            for k in range(1, n):
                текущий_макс = max(временный[k], текущий_макс + временный[k])
                общий_макс = max(общий_макс, текущий_макс)
            максимум = max(максимум, общий_макс)
    return максимум
def количество_путей_с_ограничениями(m, n, ограничения):
    dp = [[0] * n for _ in range(m)]
    dp[0][0] = 1 if (0, 0) not in ограничения else 0
    
    for i in range(m):
        for j in range(n):
            if (i, j) not in ограничения:
                if i > 0:
                    dp[i][j] += dp[i - 1][j]
                if j > 0:
                    dp[i][j] += dp[i][j - 1]
    return dp[m - 1][n - 1]
def сортировка_пузырьком(массив):
    n = len(массив)
    for i in range(n):
        for j in range(0, n - i - 1):
            if массив[j] > массив[j + 1]:
                массив[j], массив[j + 1] = массив[j + 1], массив[j]
    return массив
def сортировка_вставками(массив):
    for i in range(1, len(массив)):
        ключ = массив[i]
        j = i - 1
        while j >= 0 and массив[j] > ключ:
            массив[j + 1] = массив[j]
            j -= 1
        массив[j + 1] = ключ
    return массив
def сортировка_выбором(массив):
    n = len(массив)
    for i in range(n):
        мин_индекс = i
        for j in range(i + 1, n):
            if массив[j] < массив[мин_индекс]:
                мин_индекс = j
        массив[i], массив[мин_индекс] = массив[мин_индекс], массив[i]
    return массив
def бинарный_поиск(массив, цель):
    левый, правый = 0, len(массив) - 1
    while левый <= правый:
        середина = (левый + правый) // 2
        if массив[середина] == цель:
            return середина
        elif массив[середина] < цель:
            левый = середина + 1
        else:
            правый = середина - 1
    return -1
def найти_все_палиндромы(строка):
    палиндромы = []
    n = len(строка)
    
    def расширить_вокруг_центра(левый, правый):
        while левый >= 0 and правый < n and строка[левый] == строка[правый]:
            палиндромы.append(строка[левый:правый + 1])
            левый -= 1
            правый += 1
    
    for i in range(n):
        расширить_вокруг_центра(i, i)  # для нечётных палиндромов
        расширить_вокруг_центра(i, i + 1)  # для чётных палиндромов
    return палиндромы
def найти_все_перестановки(строка):
    if len(строка) == 1:
        return [строка]
    перестановки = []
    for i, символ in enumerate(строка):
        остальные = строка[:i] + строка[i + 1:]
        for p in найти_все_перестановки(остальные):
            перестановки.append(символ + p)
    return перестановки
def решето_Эратосфена(n):
    простые = [True] * (n + 1)
    простые[0], простые[1] = False, False
    
    for p in range(2, int(n**0.5) + 1):
        if простые[p]:
            for i in range(p * p, n + 1, p):
                простые[i] = False
    return [p for p, is_prime in enumerate(простые) if is_prime]
def КМП_поиск(текст, образец):
    def построить_таблицу_сдвигов(образец):
        таблица = [0] * len(образец)
        j = 0
        for i in range(1, len(образец)):
            while j > 0 and образец[i] != образец[j]:
                j = таблица[j - 1]
            if образец[i] == образец[j]:
                j += 1
            таблица[i] = j
        return таблица

    таблица = построить_таблицу_сдвигов(образец)
    i = j = 0
    while i < len(текст):
        if текст[i] == образец[j]:
            i += 1
            j += 1
            if j == len(образец):
                return i - j
        else:
            if j > 0:
                j = таблица[j - 1]
            else:
                i += 1
    return -1
def Рабин_Карп_поиск(текст, образец):
    n, m = len(текст), len(образец)
    if n < m:
        return -1
    хэш_образца = hash(образец)
    for i in range(n - m + 1):
        if hash(текст[i:i + m]) == хэш_образца:
            return i
    return -1

def быстрая_сортировка(массив):
    if len(массив) <= 1:
        return массив
    опорный = массив[len(массив) // 2]
    меньше = [x for x in массив if x < опорный]
    равно = [x for x in массив if x == опорный]
    больше = [x for x in массив if x > опорный]
    return быстрая_сортировка(меньше) + равно + быстрая_сортировка(больше)

def тетрарный_поиск(массив, цель):
    левый, правый = 0, len(массив) - 1
    while левый <= правый:
        m1 = левый + (правый - левый) // 3
        m2 = правый - (правый - левый) // 3
        if массив[m1] == цель:
            return m1
        if массив[m2] == цель:
            return m2
        if цель < массив[m1]:
            правый = m1 - 1
        elif цель > массив[m2]:
            левый = m2 + 1
        else:
            левый = m1 + 1
            правый = m2 - 1
    return -1

def сортировка_слиянием(массив):
    if len(массив) > 1:
        середина = len(массив) // 2
        левая = сортировка_слиянием(массив[:середина])
        правая = сортировка_слиянием(массив[середина:])
        массив = слить(левая, правая)
    return массив

def слить(левая, правая):
    результат = []
    i = j = 0
    while i < len(левая) and j < len(правая):
        if левая[i] < правая[j]:
            результат.append(левая[i])
            i += 1
        else:
            результат.append(правая[j])
            j += 1
    результат.extend(левая[i:])
    результат.extend(правая[j:])
    return результат






